---
title: dosbox使用及访问寄存器和内存
tags: 汇编
---

# 访问寄存器和内存

挂在C到asm下面

![image-20240529140528329](/image/asm/x86/mount.jpg)

## debug使用

使用`debug`进入debug模式

### 查看寄存器-R

![image-20240529140637072](/image/asm/x86/R.jpg)

r：查看寄存器内容

r 寄存器名——改变指定寄存器内容

![image-20240529140852797](/image/asm/x86/R2.jpg)

直接用`rax`也可以。

### 查看内存里面内容-D

D——列出预设地址内存处的128个字节的内容

![image-20240529141019169](/image/asm/x86/D.jpg)

前面就是`段地址：偏移地址`，$物理地址=段地址×16+偏移地址$

D 段地址：偏移地址——列出内存中指定地址处的内容

![image-20240529141312603](/image/asm/x86/D2.jpg)

D 段地址：偏移地址 结尾偏移地址

![image-20240529141413677](/image/asm/x86/D3.jpg)

### 改变内存中的内容-E

* E 段地址：偏移地址 数据1 数据2

* E 段地址：偏移地址
  * 逐个询问式修改
  * 空格-接受，继续
  * 回车-结束

​	![image-20240529142303704](/image/asm/x86/E.jpg)

![image-20240529142418560](/image/asm/x86/E2.jpg)

### 机器指令翻译成汇编指令-U

有汇编指令

```asm
mov ax,0123H
mov bx,0003H
mov ax,bx
add ax,bx
```

对应的机器码为

```
B8 23 21
BB 03 00
89 D8
01 D8
```

e 地址 数据-写入

d 地址-查看

u 地址-查看代码

![image-20240529143911213](/image/asm/x86/U.jpg)

![image-20240529144124425](/image/asm/x86/U2.jpg)

### 执行机器指令-T

t-执行CS：IP处的指令

```asm
mov ax,0123H
mov bx,003H
mov ax,bx
mov ax,bx
add ax,bx
```

![image-20240529144443052](/image/asm/x86/T.jpg)

执行完后，发现ax的值为0123了。

![image-20240529144550554](/image/asm/x86/T2.jpg)

最后执行相加后得到结果为`06`。

### 退出debug-q

## CS、IP与代码段

CS：代码段寄存器

IP：指令指针寄存器

CS:IP :CPU将内存中CS:IP指向的内容当作指令执行。

![image-20240529151657906](/image/asm/x86/CSIP.jpg)

示例：在CS和IP指示下代码的执行

8086CPU当前状态：CS中内容为2000H，IP中内容为0000H

![image-20240529151913160](/image/asm/x86/CSIP2.jpg)

可以看出，这是一条3字节的指令，也就是`mov ax,0123H`，占用了3字节，所以IP会+3，那么就是会到下一条指令了。

那么就从20000到200003了。



8086PC工作过程的简要描述：

（1）从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器

（2）IP=IP+所读取指令的长度，从而指向下一条指令

（3）执行指令。转到步骤（1），重复这个过程。



接下来用dosbox进行示例，将CS和IP修改为2000:0

然后输入以下汇编代码：

```asm
mov ax,0123
mov bx,3
mov ax,bx
add ax,bx
```

![image-20240529153819916](/image/asm/x86/CSIP3.jpg)

![image-20240529153843918](/image/asm/x86/CSIP4.jpg)

用r来看下当前指令

![image-20240529153912861](/image/asm/x86/CSIP5.jpg)

注意这里的IP是0，现在用t来执行

![image-20240529153936369](/image/asm/x86/CSIP6.jpg)

发现执行后，IP就变成了3。

再次执行

![image-20240529154007536](/image/asm/x86/CSIP7.jpg)

发现这里的IP是6。

所以从上述示例，就能感受到了

### jmp指令

修改CS、IP的指令

事实：执行何处的指令，取决于CS:IP

应用：可以通过改变CS、IP中的内容，来控制CPU要执行的没目标指令。

问题：如何改变CS、IP的值

方法一、在debug时候说过用`r`命令来改变`CS`和`IP`的值。

但是Debug是调试手段，并非是程序方式，所以这里就引出了jmp。

方法二、用指令修改

说起指令可能有人考虑到之前的mov是赋值，但是mov不能修改cs和ip的值。

### 同时修改CS、IP的内容

语法`jmp 段地址：偏移地址`

例如：jmp 2AE3:3

功能：用指令中给出的段地址修改CS，偏移地址修改 IP。

### 仅修改IP的内容

jmp 某一合法寄存器

例如：jmp ax

### 问题分析

![image-20240529161347147](/image/asm/x86/CSIP8.jpg)

假如从20000H开始执行，那么步骤如下：

(1) mov ax,6622

(2) jmp 1000:3

(3) mov ax,0000

(4) mov bx,ax

(5) jmp bx

(6) mov ax,0123H

(7) 转到第（3）步执行

关于CS:IP大致变化可以看下表

1、20000H

| CS   | 2000 | IP   | 0000 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| AX   |      | BX   |      | CX   |      |

2、20003H

这条指令就执行`jmp 1000:3`了这里执行后，CS就变成了`1000`，IP就是`3`

| CS   | 1000 | IP   | 0003 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| AX   |      | BX   |      | CX   |      |

3、10008H

因为按照示例来看bx已经是0了，所以IP就为0，CS还是1000.

| CS   | 1000 | IP   | 0000 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| AX   |      | BX   |      | CX   |      |

### 示例

按照上述，我们可以用dosbox来进行一个实际的示例运行来观察这个效果。

![image-20240530143906619](/image/asm/x86/CSIP9.jpg)

按照这个执行下来，他会执行到`jmp 1000:3`，然后到`mov ax,0`的位置，我们可以用t往后执行尝试下

![image-20240530143952534](/image/asm/x86/CSIP10.jpg)

可以看下 这里下一条就是`mov ax,0`，CS为1000，IP为0。继续执行 执行到`jmp bx`

![image-20240530144035759](/image/asm/x86/CSIP11.jpg)

接下来要执行`jmp bx`的操作了，在寄存器列表里可以看到bx的值为0，那么就会等效于`jmp 1000:0`也就是`mov ax,0123`，我们用t来看下是不是如此。

![image-20240530144135830](/image/asm/x86/CSIP12.jpg)

跟我们预想的一样。接下来的操作就循环执行了，一直到`jmp bx`，然后继续走下去。

jmp的介绍就到此结束了

## 内存中字的存储

事实：对8086CPU来说，16位作为一个字。

问题

​	16位的字存储在一个16位的寄存器中，如何存储？

回答

​	高8位放高字节，低8位放低字节

所以在进行`mov`操作的时候，我们发现`ax`还有`AH`和`AL`，比如

```asm
mov ax,4E20H
```

这里我们就可以知道AH为4E，AL为20。

一般在计算机中的存储都是小端，也就是低位放在低地址单元，高位放在高地址单元

比如说 4E20，这个存在在0、1单元。那么20是低字节，我们存在在0单元，4E是高字节，我们就存在在1单元。

![image-20240530150126144](/image/asm/x86/MemWord.jpg)

从这张图来说比较好理解点。

## DS和[address]实现字传送

要求

​	CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址

原理

​	在8086PC中，内存地址由段地址和偏移地址组成（段地址：偏移地址）

解决方案：DS和[address]配合

​	用DS寄存器存放要访问的数据的段地址

​	偏移地址用[...]形式直接给出

举个例子

```asm
mov bx,1000H
mov ds,bx
mov al,[0]
```

这里可以看ds就是`1000`，那么是段，按照之前的文章来看，段要×16，那么al的值就是1000:0也就是10000H.

那么就是将10000中的数据读到al中。

相反，也可以把al的数据写到ds:[0]中

```asm
mov bx,1000H
mov ds,bx
mov [0],al
```



同样的用dosbox来看一个案例

先给10000H开始赋值为 23 11 22 66。

![image-20240530193035307](/image/asm/x86/DS.JPG)

然后修改2000：0这部分的内容为下面

![image-20240530193157497](/image/asm/x86/DS2.JPG)

t往下执行

（1）执行MOV AX,1000：AX内容修改为1000

（2）执行MOV DS,AX：DS内容修改为1000

（3）执行MOV AX,[0000]：看这条的时候右边有写到DS：0000=1123，看下图

![image-20240530193348425](/image/asm/x86/DS3.JPG)

那么执行完AX的数据理论上就是1123，执行下。

![image-20240530193418895](/image/asm/x86/DS4.JPG)

（4）执行MOV BX,[0002]，所以BX的就为6622

![image-20240530193451049](/image/asm/x86/DS5.JPG)

其他的想必已经不用说了。由于这里是小端的，所以都是低地址在低位，就是这样的效果。

## DS与数据段

对内存单元中数据的访问

* 对于8086PC机，可以根据需要将一组内存单元定义为一个段
  * 物理地址=段地址×16+偏移地址
  * 将一组长度为N（N≤64K）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。
* 例：用123B0H~123B9H的空间来存放数据
  * 段地址：123BH  起始偏移地址：0000H
  * 段地址：1230H  起始偏移地址：00B0H

* 处理方法：（DS）：（[address]）

  * 用DS存放数据段的段地址
  * 用相关指令访问数据段中的具体单元，单元地址由[address]指出。




用DS和[address]形式访问内存中数据段方法小结

（1）字在内存中存储时，要用两个地址连续的内存单元来存放，字的低字节存放在低地址单元中，高字节存放在高地址单元中。

（2）用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。

（3）[address]表示一个偏移地址为address的内存单元

（4）在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应

（5）mov、add、sub是具有两个操作对象的指令，访问内存中的数据段（对照：jmp是具有一个操作对象的指令，对应内存中的代码段）。

（6）可以根据自己的推测，在Debug中实验指令的新格式。

## 栈及栈操作的实现

* 栈是一种只能在一端进行插入或删除操作的数据结构。
* 栈有两个基本的操作：入栈和出栈
  * 入栈：将一个新的元素放到栈顶
  * 出栈：从栈顶取出一个元素
* 栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。
* 栈的操作规则：LIFO（Last In First Out，后进先出）
* CPU提供的栈机制
  * 现今的CPU中都有栈的涉及。
  * 8086CPU提供相关的指令，支持用栈的方式访问内存空间。
  * 基于8086CPU的编程，可以将一段内存当作栈来使用。

涉及到入栈和出栈，在汇编中提供了两个命令，一个是`push`一个是`pop`

```
PUSH（入栈）和POP（出栈）指令
push ax：将ax中的数据送入栈中
pop ax：从栈顶取出数据送入ax
（以字为单位对栈进行操作）
```

假设现在有一段入栈指令

```asm
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
```

假设将10000H~1000FH内存当作栈来使用

![image-20240605135738131](/image/asm/x86/Stack.jpg)

那么就可以得到如图信息。

当执行后面三条pop之后，栈又恢复到如下图空栈状态了。

![image-20240605135910337](/image/asm/x86/Stack2.jpg)



从上面可以引出两个问题

1、CPU如何知道一段内存空间被当作栈使用

2、执行push和pop得时候，如何知道哪个单元是栈顶单元

那么之前有过CS、IP等，这里就涉及到了SS和SP寄存器

SS：栈段寄存器  存放栈顶得段地址

SP：栈顶指针寄存器 存放栈顶得偏移地址

如何时刻 SS：SP指向栈顶元素

### 栈的操作

假设有

```
mov ax,1000H
mov ss,ax
mov sp,0010H
```

那么当前`ax=1000H`，`ss=1000H`，`sp=0010`

那么她的栈顶位置就在10010H

如果进行下面操作

```
mov ax,001AH
mov bx,001BH

push ax
push bx
```

那么1000F=00  1000E=1A  1000D = 00 1000C=1B

上述等于只是里面值是多少并不是直接赋值。

![image-20240605141209016](/image/asm/x86/Stack3.jpg)

pop的话就不做演示了，就是相反操作。

### push指令和pop指令的执行过程

* push ax
  * SP=SP-2
  * 将ax中的内容送入SS:SP指向的内存单元出，SS:SP此时指向新栈顶
* pop ax
  * 将SS:SP指向的内存单元出的数据送入ax中
  * SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

但是在push和pop中会存在一个问题

* 8086 CPU不保证对栈的操作不会超界。
  * 8086CPU只知道栈顶在何处（由SS:SP指示），不知道程序安排的栈空间有多大
* 我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；防止出栈空了仍然继续出栈而导致的超界。

### 栈的小结

* push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。
* 执行push和pop指令时，SP中的内容自动改变
* 8086CPU提供的栈操作机制：
  * 在SS，SP中存放栈顶的段地址和偏移地址，入栈和出栈指令根据SS:SP指示的地址，按照栈的方式访问内存单元。
  * push指令的执行步骤：
    * SP=SP-2
    * 向SS:SP指向的字单元中送入数据。
  * pop指令的执行步骤：
    * 从SS:SP指向的字单元中读取数据
    * SP=SP-2

## 段总结

* 基础
  * 物理地址=段地址×16+偏移地址
* 做法
  * 编程时，可以根据需要将一组内存单元定义为一个段
  * 可以将起始地址为16的倍数，长度为N（N≤64K）的一组地址连续的内存单元，定义为一个段。
  * 将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元——用程序中可以完全由程序员安排。

在上述中，经历了三种段

* 数据段
  * 将段地址放在DS中
  * 用mov、add、sub等访问内存单元的指令时，CPU将我们定义的数据段中的内容当作数据段来访问
* 代码段
  * 将段地址放在CS中，将段中第一条指令的偏移地址放在IP中
  * CPU将执行我们定义的代码段中的指令
* 栈段
  * 将段地址放在SS中，将栈顶单元的偏移地址放在SP中
  * CPU在需要进行栈操作（push、pop）时，就将我们定义的栈段当作栈空间来用。



一般数据段和栈段都可以通过程序操作。数据段地址和栈段可以使用同一部分。

